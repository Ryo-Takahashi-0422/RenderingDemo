#include <stdafx.h>
#include <FBXInfoManager.h>

int FBXInfoManager::Init()
{
    // create manager
    manager = FbxManager::Create();

    // create IOSetting
    FbxIOSettings* ioSettings = FbxIOSettings::Create(manager, IOSROOT);

    // create Importer
    FbxImporter* importer = FbxImporter::Create(manager, "");
    if (importer->Initialize("C:\\Users\\RyoTaka\\Documents\\RenderingDemo-Rebuild\\FBX\\Connan_Walking_Tri.fbx", -1, manager->GetIOSettings()) == false) {

        return -1; // failed
    }

    // SceneオブジェクトにFBXファイル内の情報を流し込む
    scene = FbxScene::Create(manager, "scene");
    importer->Import(scene);
    importer->Destroy(); // シーンを流し込んだらImporterは解放してOK

    //FbxGeometryConverter converter(manager);
    //// ポリゴンを三角形にする
    //converter.Triangulate(scene, true);

    // Scene解析
    // ルートノードを取得
    FbxNode* root = scene->GetRootNode();
    if (root != 0) {
        // ぶら下がっているノードの名前を列挙
        enumNodeNamesAndAttributes(root, 0, "C:\\Users\\RyoTaka\\Documents\\RenderingDemo-Rebuild\\FBX\\Connan_Walking_Tri.fbx");
    }

    // マネージャ解放
    // 関連するすべてのオブジェクトが解放される
    scene->Destroy();
    manager->Destroy();

    return 0;
}


void FBXInfoManager::printSpace(int count)
{
    for (int i = 0; i < count; ++i)
        printf(" ");
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ★複数メッシュは読み込めるが描画出来ない。FBX SDKの仕様...?　現状解決策分からず、読み込みモデルをメッシュ結合することで回避する。
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void FBXInfoManager::enumNodeNamesAndAttributes(FbxNode* node, int indent, const std::string& filePath)
{
    //printSpace(indent);
    const char* typeNames[] = {
        "eUnknown", "eNull", "eMarker", "eSkeleton", "eMesh", "eNurbs",
        "ePatch", "eCamera", "eCameraStereo", "eCameraSwitcher", "eLight",
        "eOpticalReference", "eOpticalMarker", "eNurbsCurve", "eTrimNurbsSurface",
        "eBoundary", "eNurbsSurface", "eShape", "eLODGroup", "eSubDiv",
        "eCachedEffect", "eLine"
    };
    const char* name = node->GetName();
    int attrCount = node->GetNodeAttributeCount();
    //if (attrCount == 0) {
    //    printf("%s\n", name);
    //}
    //else {
    //    printf("%s (", name);
    //}
    for (int i = 0; i < attrCount; ++i) {
        FbxNodeAttribute* attr = node->GetNodeAttributeByIndex(i);
        FbxNodeAttribute::EType type = attr->GetAttributeType();
        //printf("%s", typeNames[type]);
        //if (i + 1 == attrCount) {
        //    printf(")\n");
        //}
        //else {
        //    printf(", ");
        //}

        //printf("%s\n", typeNames[type]);
        if (typeNames[type] == "eMesh")
        {
            // 頂点x,y,z座標の抽出及びverticesへの格納
            fbxMeshes.resize(meshCnt);
            fbxMesh = (FbxMesh*)attr;
            fbxMeshes.emplace_back(fbxMesh);
            ++meshCnt;

            // UVセット名の取得
            // * 現在の実装だとは1つのUVセット名にしか対応していない...
            FbxStringList uvSetNameList;
            fbxMesh->GetUVSetNames(uvSetNameList);
            const char* uvSetName = uvSetNameList.GetStringAt(0);
            // 頂点座標情報のリストを生成
            std::vector<std::vector<float>> vertexInfoList;
            for (int i = 0; i < fbxMesh->GetControlPointsCount(); i++)
            {
                // 頂点座標を読み込んで設定
                auto point = fbxMesh->GetControlPointAt(i);
                std::vector<float> vertex;
                vertex.push_back(point[0]);
                vertex.push_back(point[1]);
                vertex.push_back(point[2]);
                vertexInfoList.push_back(vertex);
            }
            // 頂点毎の情報を取得する
            std::vector<unsigned short> indices;
            std::vector<unsigned short> indicesFiexed4DirectX;
            std::vector<std::array<int, 2>> oldNewIndexPairList;
            for (int polIndex = 0; polIndex < fbxMesh->GetPolygonCount(); polIndex++) // ポリゴン毎のループ
            {
                for (int polVertexIndex = 0; polVertexIndex < fbxMesh->GetPolygonSize(polIndex); polVertexIndex++) // 頂点毎のループ
                {
                    printf("%d\n", fbxMesh->GetPolygonCount());
                    printf("%d\n", fbxMesh->GetPolygonSize(polIndex));
                    // インデックス座標
                    auto vertexIndex = fbxMesh->GetPolygonVertex(polIndex, polVertexIndex);
                    // 頂点座標
                    std::vector<float> vertexInfo = vertexInfoList[vertexIndex];
                    // 法線座標
                    FbxVector4 normalVec4;
                    fbxMesh->GetPolygonVertexNormal(polIndex, polVertexIndex, normalVec4);
                    // UV座標
                    FbxVector2 uvVec2;
                    bool isUnMapped;
                    fbxMesh->GetPolygonVertexUV(polIndex, polVertexIndex, uvSetName, uvVec2, isUnMapped);
                    // インデックス座標のチェックと再採番
                    if (!IsExistNormalUVInfo(vertexInfo))
                    {
                        // 法線座標とUV座標が未設定の場合、頂点情報に付与して再設定
                        vertexInfoList[vertexIndex] = CreateVertexInfo(vertexInfo, normalVec4, uvVec2);
                    }
                    else if (!IsSetNormalUV(vertexInfo, normalVec4, uvVec2))
                    {
                        // ＊同一頂点インデックスの中で法線座標かUV座標が異なる場合、
                        // 新たな頂点インデックスとして作成する
                        vertexIndex = CreateNewVertexIndex(vertexInfo, normalVec4, uvVec2, vertexInfoList, vertexIndex, oldNewIndexPairList);
                    }
                    // インデックス座標を設定

                    indices.push_back(vertexIndex);
                }
            }
            // 頂点情報を生成
            std::vector<FBXVertex> vertices;
            for (int i = 0; i < vertexInfoList.size(); i++)
            {
                std::vector<float> vertexInfo = vertexInfoList[i];
                vertices.push_back(FBXVertex{
                    {
                        -vertexInfo[0], vertexInfo[1], vertexInfo[2] // なぜかY軸ミラーされた状態の頂点座標になっている。ので、とりあえずX座標値に-1しとく。
                    },
                    {
                        vertexInfo[3], vertexInfo[4], vertexInfo[5] // ↑の影響に注意
                    },
                    {
                        vertexInfo[6], /*1.0f - */vertexInfo[7] // Blenderで作成した場合、V値は反転させる
                    }
                    });
            }

            //// 左手系インデクスに修正
            //for (int i = 0; i < /*fbxMesh->GetPolygonCount()*/indices.size() / 3; ++i)
            //{
            //    // 2 => 1 => 0にしてるのは左手系対策
            //    indicesFiexed4DirectX.push_back(indices[i * 3 + 2]);
            //    indicesFiexed4DirectX.push_back(indices[i * 3 + 1]);
            //    indicesFiexed4DirectX.push_back(indices[i * 3]);
            //}

            finalInfo[name] = { vertices, indices/*indicesFiexed4DirectX*/ };
        }

    }

    int childCount = node->GetChildCount();

    for (int i = 0; i < childCount; ++i) {
        enumNodeNamesAndAttributes(node->GetChild(i), indent + 1, "C:\\Users\\RyoTaka\\Documents\\RenderingDemo-Rebuild\\FBX\\Connan_Walking_Tri.fbx");
    }
}

// 法線、UV情報が存在しているか？
bool FBXInfoManager::IsExistNormalUVInfo(const std::vector<float>& vertexInfo)
{
    return vertexInfo.size() == 8; // 頂点3 + 法線3 + UV2
}
// 頂点情報を生成
std::vector<float> FBXInfoManager::CreateVertexInfo(const std::vector<float>& vertexInfo, const FbxVector4& normalVec4, const FbxVector2& uvVec2)
{
    std::vector<float> newVertexInfo;
    // 位置座標
    newVertexInfo.push_back(vertexInfo[0]);
    newVertexInfo.push_back(vertexInfo[1]);
    newVertexInfo.push_back(vertexInfo[2]);
    // 法線座標
    newVertexInfo.push_back(normalVec4[0]);
    newVertexInfo.push_back(normalVec4[1]);
    newVertexInfo.push_back(normalVec4[2]);
    // UV座標
    newVertexInfo.push_back(uvVec2[0]);
    newVertexInfo.push_back(uvVec2[1]);
    return newVertexInfo;
}

// 新たな頂点インデックスを生成する
int FBXInfoManager::CreateNewVertexIndex(const std::vector<float>& vertexInfo, const FbxVector4& normalVec4, const FbxVector2& uvVec2,
    std::vector<std::vector<float>>& vertexInfoList, int oldIndex, std::vector<std::array<int, 2>>& oldNewIndexPairList)
{
    // 作成済の場合、該当のインデックスを返す
    for (int i = 0; i < oldNewIndexPairList.size(); i++)
    {
        int newIndex = oldNewIndexPairList[i][1];
        if (oldIndex == oldNewIndexPairList[i][0]
            && IsSetNormalUV(vertexInfoList[newIndex], normalVec4, uvVec2))
        {
            return newIndex;
        }
    }
    // 作成済でない場合、新たな頂点インデックスとして作成
    std::vector<float> newVertexInfo = CreateVertexInfo(vertexInfo, normalVec4, uvVec2);
    vertexInfoList.push_back(newVertexInfo);
    // 作成したインデックス情報を設定
    int newIndex = vertexInfoList.size() - 1;
    std::array<int, 2> oldNewIndexPair{ oldIndex , newIndex };
    oldNewIndexPairList.push_back(oldNewIndexPair);
    return newIndex;
}
// vertexInfoに法線、UV座標が設定済かどうか？
bool FBXInfoManager::IsSetNormalUV(const std::vector<float> vertexInfo, const FbxVector4& normalVec4, const FbxVector2& uvVec2)
{
    // 法線、UV座標が同値なら設定済とみなす
    return fabs(vertexInfo[3] - normalVec4[0]) < FLT_EPSILON
        && fabs(vertexInfo[4] - normalVec4[1]) < FLT_EPSILON
        && fabs(vertexInfo[5] - normalVec4[2]) < FLT_EPSILON
        && fabs(vertexInfo[6] - uvVec2[0]) < FLT_EPSILON
        && fabs(vertexInfo[7] - uvVec2[1]) < FLT_EPSILON;
}